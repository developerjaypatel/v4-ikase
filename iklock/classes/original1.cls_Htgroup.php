<?php
/*	**************************************************************

	class.Htgroup.php3

	A class to manage httpd group files used for Basic Authentication

	Copyright (c) 1999, CDI - cdi@thewebmasters.net
	All Rights Reserved.
	See the included documentation for full LICENSE.

	**************************************************************
	History
	Revision 0.1	Session 1 start Jan 31 ~10:00PM
					Project started, session ended with 12 methods

	Revision 0.2	Session 2 start Feb 01, 09:15AM-12:00PM
					Bare bones operational, added 4 methods

	Revision 0.3	Session 3 start Feb 01, 02:30PM-04:23PM
					Modified the add? methods to handle arrays as
					arguments. Added 6 more methods

	Revision 0.4	Fully operational, time for the documentation.

	**************************************************************
*/

class Htgroup {

	// Globally accessable variables

	var	$VERSION	= 'Revision 0.4 (BETA) 1999/02/01 cdi@thewebmasters.net';

	var $WIN32		= false;	// Set to true for M$ BloatWare servers


	var $FILE		= "";		// Filename Holder
	var $ERROR		= "";		// Last error message
	var $EMPTY		= false;	// Is the FILE empty?
	var $CONTENTS	= "";		// Raw htpasswd contents
	var $EXISTS		= false;	// Boolean. True if $FILE exists
	var $SANE		= false;	// Boolean. True if $FILE passes all tests
	var $IDIOT		= false;	// Boolean. True if user is an idiot.
	var $DEBUG		= true;		// Boolean. Logs errors to error_log if set
	var $GROUPS		= array();	// Array of [index#][(user|pass)]=value
	var $GROUPCOUNT	= 0;		// Counter - total number of users in $FILE
								// Zero based indexing on $GROUPS


//	**************************************************************
	function Htgroup ($groupFile = "")
	{
		if(!empty($groupFile))
		{
			$this->initialize($groupFile);
		}
		return;
	}

//	**************************************************************
	function initialize ($groupFile)
	{
		//echo "file: " . $groupFile . "<BR>";
		$this->FILE	=	$groupFile;
		srand((double)microtime()*1000000); // Seed the random number gen

		if(empty($groupFile))
		{
			// PHP is going to bitch about this, this is here just because
			$this->error("Invalid initialize() or new() method: No file specified!",1);
			exit; // Just in case
		}

		if(file_exists($this->FILE))
		{
			$this->EXISTS = true;
			//echo "us: yea"	. "<br>";		
			if($this->sane($this->FILE))
			{
				
				$this->SANE = true;
				//echo "sane<BR>";
				$this->htReadFile();
			}
			else
			{
				// Preserve the error generated by sane()
				echo $this->error;
				return;
			}
		}
		else
		{
			//echo "us: nyea"	. "<br>";
			$this->SANE=true;	// Non-existant files are safe
		}
		return;
	}

//	**************************************************************
	function do_not_blame_cdi ()
	{
		$this->IDIOT = true;
		$this->error("No sanity checking on files",0);
		return;
	}

//	**************************************************************
	function sane ($filename)
	{
		if ($this->IDIOT)
		{
			return true;
		}

		// If it's a Win32 box, there's no sense in doing all this

		if ($this->WIN32)
		{
			// You're on your own
			return true;
		}

		//	Some kind of *nix machine - let's do some
		//	rudimentary checks

		if (!(is_readable($filename)))
		{
			$this->error("File [$filename] not readable",0);
			echo "File [$filename] not readable";
			return false;
		}
		if (!(is_writeable($filename)))
		{
			$this->error("File [$filename] not writeable",0);
			echo "File [$filename] not writeable";
			return false;
		}
		if(is_dir($filename))
		{
			$this->error("File [$filename] is a directory",0);
			return false;
		}
		if(is_link($filename))
		{
			$this->error("File [$filename] is a symlink",0);
			return false;
		}
		return true;
	}

//	**************************************************************
	function version ()
	{
		return $this->VERSION;
	}

//	**************************************************************
	function error ($errMsg,$die)
	{
		$this->ERROR = "[Htgroup] $errMsg";

		if( (!($this->DEBUG)) && ($die != 1) )
		{
			return;
		}

		if ($this->DEBUG)
		{
			error_log($this->ERROR,0);
		}

		if($die == 1)
		{
			echo "<B> ERROR $this->ERROR </B> <BR> \n";
			exit;
		}

		return;
	}

//	**************************************************************
	function htReadFile ()
	{
		global	$php_errormsg;

		$Mytemp		= array();
		$Myjunk 	= array();
		$count		= 0;
		$empty		= false;
		$contents 	= "";

		$filename 	= $this->FILE;
		$filesize 	= filesize($filename);
//echo "size" . $filesize ;
		if($filesize < 3) { $empty = true; }
		
		if(!($empty))
		{
			$this->EMPTY = false;

			$fd = fopen( $filename, "r" );
//die("file: " . $filename);
			if(empty($fd))
			{
				$this->error("FATAL File access error [$php_errormsg]",1);
				exit; // Just in case
			}

			$contents = fread( $fd, filesize( $filename ) );
			fclose( $fd );

			$this->CONTENTS = $contents;
			//clean up
			$contents = str_replace("\r\n", "\n", $contents);
			$Mytemp	= split("\n",$contents);
			for($count=0;$count<count($Mytemp);$count++)
			{
				$group = "";
				$user = "";

				if(empty($Mytemp[$count]))					{ break; }
				if(ereg("^(\n|\W)(.?)",$Mytemp[$count]))	{ break; }

				if(!(ereg(":",$Mytemp[$count])))
				{
					$group = $Mytemp[$count];
					$errno=($count+1);
					$this->error("FATAL invalid group [$group] on line [$errno] in [$filename]",1);
				}

				list ($group,$users) = split(":",$Mytemp[$count]);

				if ( ($group != "") )
				{
					$users = ereg_replace("^([ 	]+)","",$users);
					$UArray = explode(" ",$users);
					$Myjunk[$group] = $UArray;
				}

			}

			$this->GROUPS		= $Myjunk;
			$this->GROUPCOUNT	= $count;

		}
		else
		{
			// Empty file. Label it as such

			$this->GROUPS		= $Myjunk;
			$this->GROUPCOUNT	= -1;
			$this->EMPTY		= true;
		}

		return;

	}	// end htReadFile()

//	**************************************************************
	function isGroup ($GroupID)
	{
		if(empty($GroupID)) { return false; }

		$match = false;
		$MyTemp = $this->GROUPS;

		while(list ($group,$users) = each ($MyTemp) )
		{
			if ($GroupID == $group)
			{
				$match = true;
			}
		}

		return $match;
	}

//	**************************************************************
	function getGroupNum ($GroupID)
	{
		$groupNum = -1;
		$count = 0;

		if(empty($GroupID)) { return $groupNum; }

		if(!$this->isGroup($GroupID))
		{
			$this->error("Group [$GroupID] does not exist",0);
			return $groupNum;
		}

		$MyTemp = $this->GROUPS;
		while(list ($group,$users) = each ($MyTemp) )
		{
			if ($GroupID == $group)
			{
				$groupNum = $count;
			}
			$count++;
		}

		return $groupNum;
	}

//	**************************************************************
	function renameGroup ($GroupID,$NewID)
	{
		if(empty($GroupID)) { return false; }
		if(empty($NewID))	{ return false; }

		$match = false;
		if(!$this->isGroup($GroupID))
		{
			$this->error("Cannot rename non-existant group",0);
			return false;
		}
		if($this->isGroup($NewID))
		{
			$this->error("New group [$NewID] already exists",0);
			return false;
		}
		$MyTemp = $this->GROUPS;

		$MyTemp[$NewID] = $MyTemp[$GroupID];
		unset($MyTemp[$GroupID]);

		$this->GROUPS = $MyTemp;

		$this->htWriteFile();

		return true;
	}

//	**************************************************************
	function addGroup ($GroupID, $Users = "")
	{
		
		if(empty($GroupID)) { return false; }
		if(!empty($Users))
		{
			if ( (gettype($Users)) != "array")
			{
				$this->error("Invalid data type [$Users], expected array",0);
				return false;
			}
		}
		else
		{
			$Users = array();
		}

		if($this->isGroup($GroupID))
		{
			$this->error("Group [$GroupID] already exists",0);
			return false;
		}
		
		$MyTemp = $this->GROUPS;

		$MyTemp[$GroupID] = $Users;

		$this->GROUPS = $MyTemp;

		$this->htWriteFile();
		return true;
	}

//	**************************************************************
	function isUserInGroup ($UserID, $GroupID)
	{
		if (empty($UserID))				{ return false; }
		if ($this->EMPTY)				{ return false; }
		if (!$this->isGroup($GroupID))	{ return false; }
		
//		echo "group: ". $GroupID . "<br>";
//		die(print_r($this->GROUPS) . "<BR>");
		$Group = $this->GROUPS[$GroupID];
//		
		if(empty($Group))
		{
			$this->error("Specified Group [$GroupID] ",0);
			return false;
		}

		while ( list ($key,$user) = each ($Group) )
		{
			if ($UserID == $user)
			{
				$found = true;
				//echo $key . " -> found: ". $found . "<BR>";
			}
		}
		
		return $found;

    } // end isUserInGroup

//	**************************************************************
	function getGroups ()
	{
		$Groups = array();
		if ($this->EMPTY) { return false; }

		$MyTemp = $this->GROUPS;
		while ( list ($GroupID,$users) = each ($MyTemp) )
		{
			$Groups[$GroupID] = $GroupID;
		}
		return $Groups;
	}
	function selectGroups ($group = "", $multiple = "multiple")
	{
		$select = "";
		if ($group!="") {
			$arrGroups = explode(",",$group);
		}
		
		if ($this->EMPTY) { return false; }

		$MyTemp = $this->GROUPS;
		while ( list ($GroupID,$users) = each ($MyTemp) )
		{
			$selected = "";
			$intCounter = 0;
			while ($intCounter<count($arrGroups)) {
				if ($arrGroups[$intCounter]==$GroupID) {
					$selected = " selected";
				}
				$intCounter++;
			}
			$select .= "<option value='" . $GroupID . "'" . $selected . ">"  . $GroupID . "</option>";
		}
		
		$select = "<select name='group_select[]' " . $multiple . ">" . $select . "</select>";
		return $select;
	}
//	**************************************************************
	function getUsers ()
	{
		$Groups = array();
		$Users = array();
		$Return = array();

		$MyTemp = $this->GROUPS;
		while ( list ($GroupID,$users) = each ($MyTemp) )
		{
			while ( list ($key,$UserName) = each ($users) )
			{
				if (!$Return[$UserName])
				{
					$Return[$UserName] = $UserName;
				}
			}
		}

		return $Return;
	}
//	**************************************************************
	function getGroupsForUser ($UserID)
	{
		$Groups = array();
		$count = 0;
		$found = true;

		if (empty($UserID))				{ return false; }
		$MyTemp = $this->GROUPS;

		while (list ($GroupID,$users) = each ($MyTemp) )
		{
			if($this->isUserInGroup($UserID,$GroupID))
			{
				$found = true;
				$Groups[$count] = $GroupID;
			}
			$count++;
		}
		if(!$found)
		{
			unset($Groups);
		}

		return $Groups;

    } // end getGroupsForUser

//	**************************************************************
	function getUsersForGroup($GroupID)
	{
		$Users = array();
		$count = 0;
		$found = true;

		if (empty($GroupID))
		{
			unset($Users);
			return $Users;
		}

		$MyTemp = $this->GROUPS;

		while (list ($GroupName,$users) = each ($MyTemp) )
		{
			if($GroupID == $GroupName)
			{
				$found = true;
				$Users = $users;
			}
		}
		if(!$found)
		{
			unset($Users);
		}

		return $Users;

    } // end getUsersForGroup

//	**************************************************************
	function addUser ($UserID,$GroupID)
	{
		$Groups = $this->GROUPS;
		//die("groups: " . count($Groups));
		$Users = $Groups[$GroupID];
		$count = count($Users);
		$Users[$count] = $UserID;
		$Groups[$GroupID] = $Users;
		$this->GROUPS = $Groups; 
	}

//	**************************************************************
	function addUserToGroup ($UserID,$GroupID)
	{
		if(empty($UserID))
		{
			$this->error("Cannot add empty userid",0);
			return false;
		}
		if(empty($GroupID))
		{
			$this->error("Cannot add user without group",0);
			return false;
		}

		if(!$this->isGroup($GroupID))
		{
			$this->error("Creating new group [$GroupID]",0);
			$this->addGroup($GroupID,$UserID);
			return true;
		}
		if( (gettype($UserID)) != "array")
		{
			// Add one user to the array
			if($this->isUserInGroup($UserID,$GroupID))
			{
				$this->error("User [$UserID] is already a member of [$GroupID]",0);
				return false;
			}
			else
			{
				//echo "add $UserID, $GroupID<br>";
				$this->addUser($UserID,$GroupID);
			}
		}
		else
		{
			// Add multiple users to the array
			while ( list ($key,$UserName) = each ($UserID) )
			{
				if($this->isUserInGroup($UserName,$GroupID))
				{
					$this->error("Skipping [$UserName], already a member of [$GroupID]",0);
				}
				else
				{
					// add users
					$this->addUser($UserName,$GroupID);
				}
			}
		}	// end else

		//	Finished adding - save the file

		$this->htWriteFile();
		return true;
	}

//	**************************************************************
	function deleteUser($UserID,$GroupID)
	{
		$Group = $this->GROUPS[$GroupID];
		if(empty($Group))
		{
			$this->error("Specified Group [$GroupID] does not exist",0);
			return false;
		}
		while ( list ($key,$user) = each ($Group) )
		{
			if ($user == $UserID)
			{
				//echo "unset:(" . $this->GROUPS[$GroupID][$key]  . ")<Br>";
				unset($this->GROUPS[$GroupID][$key]);
				return true;
			}
		}
	}

//	**************************************************************
	function deleteUserFromGroup ($UserID,$GroupID)
	{
		$removed = false;
		//echo "del: ". $UserID.", " . $GroupID . "<BR>";
		if (empty($UserID))	{ return false; }
		if ($this->EMPTY)	{ return false; }
		if( (gettype($UserID)) == "array" )
		{
			//	Delete multiple users from array
			while( list ($key,$UserName) = each ($UserID) )
			{
				if ($this->isUserInGroup($UserName,$GroupID))
				{
					//echo "user in group<br>";
					if(!$this->deleteUser($UserName,$GroupID))
					{
						return false;
					}
				}
				else
				{
					$this->error("Skipping [$UserName], not found in [$GroupID]",0);
				}
			}
		}
		else
		{
			//	Delete one user from the array
			if (!$this->isUserInGroup($UserID,$GroupID))
			{
				$this->error("User [$UserID] is not a member of group [$GroupID]",0);
				return false;
			}
			else
			{
				$this->deleteUser($UserID,$GroupID);
			}
		}

		//	Finished deleting - save the file

		$this->htWriteFile();

		return true;
	}


//	**************************************************************
	function deleteGroup ($GroupID)
	{
		$removed = false;

		if (empty($GroupID))	{ return false; }
		if ($this->EMPTY)		{ return false; }

		$Group = $this->GROUPS[$GroupID];

		if(empty($Group))
		{
			$this->error("Specified Group [$GroupID] does not exist",0);
			return $removed;
		}
		unset($this->GROUPS[$GroupID]);

		$removed = true;

		$this->htWriteFile();

		return $removed;
	}


//	**************************************************************
	function htWriteFile ()
	{
		global $php_errormsg;

		$filename = $this->FILE;
		//echo "writing $filename";
		$tempfile   = tempnam( "/tmp", "fort" );
		//die("tp:" . $tempfile . "<br>fil:" . $filename);
		if (!copy($filename, $tempfile))
		{
			$this->error("FATAL cannot create backup file [$tempfile] :  [$php_errormsg]",1);
			exit;
		}
		$fd = fopen( $tempfile, "w" );

		if(empty($fd))
		{
			$myerror = $php_errormsg;
			unlink($tempfile);
			$this->error("FATAL File [$tempfile] access error [$myerror]",1);
			exit;
		}

		$MyTemp = $this->GROUPS;

		while (list ($GroupName,$UserNames) = each ($MyTemp) )
		{
			if(!empty($GroupName))
			{
				fwrite($fd, "$GroupName:");
				if ( (gettype($UserNames)) != "array")
				{
					$UserNames = ereg_replace("([ 	]+)","",$UserNames);
					if(!empty($UserNames))
					{
						
						fwrite($fd, " $UserNames");
					}
				}
				else
				{
					while (list ($key,$User) = each ($UserNames) )
					{
						$User = ereg_replace("([ 	]+)","",$User);
						if(!empty($User))
						{
							fwrite($fd, " $User");
						}
					}
				}
				fwrite($fd, "\n");
			}

		}	// end while GROUPS

		fclose($fd);

		if (!copy($tempfile, $filename))
		{
			$myerror = $php_errormsg;   // Stash the error, see above
			unlink($tempfile);
			$this->error("FATAL cannot copy file [$filename] [$myerror]",1);
			exit;   // Just in case
		}

		unlink($tempfile);
		if(file_exists($tempfile))
		{
			// Not fatal but it should be noted
			$this->error("Could not unlink [$tempfile] : [$php_errormsg]",0);
		}

		$this->CONTENTS = "";
		$this->GROUPS = "";
		$this->initialize($filename);

		return true;

	}

//	**************************************************************
//	**************************************************************

}   // END CLASS.HTPASSWD

?>
